<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Vejledningsplanl√¶gger</title>
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl"],
        files: {
          "streamlit_app.py": `
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import io
import re

st.set_page_config(page_title="Vejledningsplanl√¶gger", layout="wide")

st.markdown("""
<style>
    [data-testid="stSidebar"] { min-width: 400px !important; }
    label[data-testid="stWidgetLabel"] p { white-space: nowrap !important; display: inline-block !important; }
</style>
""", unsafe_allow_html=True)

st.title("üìÖ Vejledningsplanl√¶gger")
st.info("Denne app k√∏rer 100% lokalt i din browser (GDPR-sikker).")

st.sidebar.header("Indstillinger")
start_tid_str = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="08:15")
varighed = st.sidebar.number_input("Minutter pr. vejledning", value=15)
pause_input = st.sidebar.text_area("Pauser", value="09:50-10:10, 11:45-12:15, 13:50-14:00")

def parse_pauser(pause_str):
    pauser = []
    matches = re.findall(r"(\\d{1,2}[:.]\\d{2})\\s*-\\s*(\\d{1,2}[:.]\\d{2})", pause_str)
    for m in matches:
        try:
            p_s = datetime.strptime(m[0].replace(".", ":"), "%H:%M")
            p_e = datetime.strptime(m[1].replace(".", ":"), "%H:%M")
            pauser.append((p_s, p_e))
        except: continue
    return sorted(pauser)

def is_overlapping(s1, e1, s2, e2):
    return s1 < e2 and e1 > s2

def solve_final_logic(df, start_str, pauses):
    try:
        start_str = start_str.replace(".", ":")
        global_start = datetime.strptime(start_str, "%H:%M")
    except: return None

    # 1. Belastning og rangering
    t_counts = pd.concat([df['L√¶rer1'], df['L√¶rer2']]).astype(str).str.strip().value_counts().to_dict()
    all_teachers = sorted(t_counts.keys(), key=lambda x: (t_counts[x], x), reverse=True)
    teacher_rank = {teacher: i for i, teacher in enumerate(all_teachers)}

    # 2. Planl√¶g tider (Makkerpar-stimer)
    df['pair_key'] = df.apply(lambda r: tuple(sorted([str(r['L√¶rer1']).strip(), str(r['L√¶rer2']).strip()])), axis=1)
    pair_groups = df.groupby('pair_key')
    sorted_groups = []
    for key, group in pair_groups:
        weight = len(group) * 1000 + (2000 - teacher_rank.get(key[0], 999) - teacher_rank.get(key[1], 999))
        sorted_groups.append({'key': key, 'data': group, 'weight': weight})
    sorted_groups = sorted(sorted_groups, key=lambda x: x['weight'], reverse=True)

    teacher_busy_slots = {t: [] for t in all_teachers}
    planned_times = []

    for group in sorted_groups:
        pair = group['key']
        sessions = group['data'].to_dict('records')
        total_min = len(sessions) * varighed
        curr = global_start
        found = False
        while not found:
            s_block, e_block = curr, curr + timedelta(minutes=total_min)
            if any(is_overlapping(s_block, e_block, ps, pe) for ps, pe in pauses):
                curr = next(pe for ps, pe in pauses if is_overlapping(s_block, e_block, ps, pe))
                continue
            if any(any(is_overlapping(s_block, e_block, bs, be) for bs, be in teacher_busy_slots[t]) for t in pair):
                curr += timedelta(minutes=1)
                continue
            found = True
        for s in sessions:
            s_e = curr + timedelta(minutes=varighed)
            planned_times.append({**s, 's_dt': curr, 'e_dt': s_e})
            for t in pair: teacher_busy_slots[t].append((curr, s_e))
            curr = s_e

    # 3. Bordplanl√¶gning (2-PASS PRIORITERING)
    planned_times.sort(key=lambda x: x['s_dt'])
    time_points = []
    for s in planned_times:
        time_points.append((s['s_dt'], 1)); time_points.append((s['e_dt'], -1))
    time_points.sort()
    max_c, cur_c = 0, 0
    for _, d in time_points:
        cur_c += d
        max_c = max(max_c, cur_c)

    teacher_home_table = {all_teachers[i]: i+1 for i in range(min(len(all_teachers), max_c))}
    table_occupied = [] # List of (table, start, end)
    final_sessions = []

    # PASS 1: Tildel sessioner med Home-Table ejere
    owner_sessions = [s for s in planned_times if str(s['L√¶rer1']).strip() in teacher_home_table or str(s['L√¶rer2']).strip() in teacher_home_table]
    owner_sessions.sort(key=lambda x: x['s_dt'])
    
    for s in owner_sessions:
        l1, l2 = str(s['L√¶rer1']).strip(), str(s['L√¶rer2']).strip()
        h1, h2 = teacher_home_table.get(l1), teacher_home_table.get(l2)
        # V√¶lg den mest travles bord
        if h1 and h2: assigned = h1 if teacher_rank[l1] < teacher_rank[l2] else h2
        else: assigned = h1 if h1 else h2
        table_occupied.append((assigned, s['s_dt'], s['e_dt']))
        s['bord_nr'] = assigned

    # PASS 2: Tildel floaters (ingen af l√¶rerne ejer et bord)
    floater_sessions = [s for s in planned_times if 'bord_nr' not in s]
    floater_sessions.sort(key=lambda x: x['s_dt'])
    
    pair_streak_table = {}
    for i, s in enumerate(floater_sessions):
        l1, l2 = str(s['L√¶rer1']).strip(), str(s['L√¶rer2']).strip()
        pair = s['pair_key']
        if pair in pair_streak_table:
            assigned = pair_streak_table[pair]
        else:
            # Find streak end
            s_end = s['e_dt']
            for ns in floater_sessions[i+1:]:
                if ns['pair_key'] == pair and ns['s_dt'] == s_end: s_end = ns['e_dt']
                elif ns['s_dt'] > s_end: break
            
            t_nr = 1
            while True:
                if not any(t_nr == ot and is_overlapping(s['s_dt'], s_end, os, oe) for ot, os, oe in table_occupied):
                    assigned = t_nr; break
                t_nr += 1
            if s_end > s['e_dt']: pair_streak_table[pair] = assigned
        
        # Ryd streak
        is_last = True
        for ns in floater_sessions[i+1:]:
            if ns['pair_key'] == pair and ns['s_dt'] == s['e_dt']: is_last = False; break
        if is_last and pair in pair_streak_table: del pair_streak_table[pair]
        
        table_occupied.append((assigned, s['s_dt'], s['e_dt']))
        s['bord_nr'] = assigned

    for s in planned_times:
        s['Starttid'], s['Sluttid'], s['Bord'] = s['s_dt'].strftime("%H:%M"), s['e_dt'].strftime("%H:%M"), f"Bord {s['bord_nr']}"
        final_sessions.append(s)

    return pd.DataFrame(final_sessions).sort_values(['Starttid', 'bord_nr']), teacher_rank

# --- UI ---
st.markdown("---")
st.subheader("Instruktion")
st.write("Upload Excel: K.id., Fornavn, Efternavn, Fag1, L√¶rer1, Fag2, L√¶rer2")
uploaded_file = st.file_uploader("V√¶lg Excel-fil", type=["xlsx"])

if uploaded_file:
    try:
        input_df = pd.read_excel(uploaded_file)
        pauser = parse_pauser(pause_input)
        result, t_rank = solve_final_logic(input_df, start_tid_str, pauser)
        
        if result is not None:
            st.success("‚úÖ Planl√¶gning f√¶rdig!")

            def get_excel(data, mode):
                output = io.BytesIO()
                # Vi fjerner bord_nr fra alle exports
                export_df = data.drop(columns=['pair_key', 's_dt', 'e_dt', 'bord_nr'], errors='ignore')
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    if mode == 'laerer':
                        export_df.to_excel(writer, sheet_name='Samlet Plan', index=False)
                        for l in sorted(list(set(data['L√¶rer1'].astype(str)) | set(data['L√¶rer2'].astype(str)))):
                            data[(data['L√¶rer1']==l)|(data['L√¶rer2']==l)].drop(columns=['pair_key', 's_dt', 'e_dt', 'bord_nr'], errors='ignore').to_excel(writer, sheet_name=f"L√¶rer {l[:25]}", index=False)
                    elif mode == 'elev':
                        export_df.sort_values(['Fornavn', 'Efternavn']).to_excel(writer, sheet_name='Navne', index=False)
                        d_t = data.copy(); d_t['Kl'] = d_t['K.id.'].astype(str).str[:2]
                        for k in sorted(d_t['Kl'].unique()):
                            d_t[d_t['Kl']==k].drop(columns=['Kl','pair_key','s_dt','e_dt','bord_nr'], errors='ignore').to_excel(writer, sheet_name=f"Klasse {k}", index=False)
                    elif mode == 'bord':
                        export_df.to_excel(writer, sheet_name='Samlet Plan', index=False)
                        for b in sorted(data['bord_nr'].unique()):
                            data[data['bord_nr']==b].drop(columns=['pair_key', 's_dt', 'e_dt', 'bord_nr'], errors='ignore').to_excel(writer, sheet_name=f"Bord {b}", index=False)
                return output.getvalue()

            st.markdown("### üì• Download resultater")
            c1, c2, c3 = st.columns(3)
            c1.download_button("üìÇ Hent L√¶rer-planer", get_excel(result, 'laerer'), "laerer_planer.xlsx")
            c2.download_button("üéì Hent Elev-planer", get_excel(result, 'elev'), "elev_planer.xlsx")
            c3.download_button("üñºÔ∏è Hent Bord-planer", get_excel(result, 'bord'), "bord_planer.xlsx")

            st.markdown("---")
            st.subheader("üìä L√¶reroversigt (Travlhed & Stabilitet)")
            teachers = sorted(list(set(result['L√¶rer1'].astype(str)) | set(result['L√¶rer2'].astype(str))))
            ranking_data = []
            for t in teachers:
                t_sessions = result[(result['L√¶rer1'] == t) | (result['L√¶rer2'] == t)].sort_values('s_dt')
                switches = []
                prev_b = None
                for _, row in t_sessions.iterrows():
                    if prev_b and row['Bord'] != prev_b:
                        other = row['L√¶rer2'] if row['L√¶rer1'] == t else row['L√¶rer1']
                        cause = "H√∏jere" if t_rank[other] < t_rank[t] else "Lavere"
                        switches.append(f"Til {row['Bord']} pga. {other} ({cause} rang)")
                    prev_b = row['Bord']
                ranking_data.append({"L√¶rer": t, "Antal vejledninger": len(t_sessions), "Skal skifte bord": "üî¥ Ja" if switches else "üü¢ Nej", "√Örsag til skift": ", ".join(switches) if switches else "Ingen"})
            st.dataframe(pd.DataFrame(ranking_data).sort_values("Antal vejledninger", ascending=False), use_container_width=True, hide_index=True)

    except Exception as e:
        st.error(f"Fejl: {e}")
`
        },
      });
    </script>
  </body>
</html>
