<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Vejledningsplanl√¶gger</title>
    <script src="https://cdn.jsdelivr.net/gh/gzuidhof/coi-serviceworker@latest/coi-serviceworker.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl"],
        files: {
          "streamlit_app.py": `
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import io
import re

st.set_page_config(page_title="Vejledningsplanl√¶gger", layout="wide")

st.markdown("""
<style>
    [data-testid="stSidebar"] { min-width: 380px !important; }
    label[data-testid="stWidgetLabel"] p {
        white-space: nowrap !important;
        display: inline-block !important;
        margin-right: 5px !important;
    }
</style>
""", unsafe_allow_html=True)

st.title("üìÖ Vejledningsplanl√¶gger")
st.info("Optimeret logik: Minimale antal borde, men 0 bordskift for de travleste l√¶rere.")

# --- SIDEBAR ---
st.sidebar.header("Indstillinger")
start_tid_str = st.sidebar.text_input("Starttidspunkt (tt.mm)", value="08:00", help="Brug formatet 08:00 eller 08.00")
varighed = st.sidebar.number_input("Minutter pr. vejledning", value=15, help="Standard er 15 min.")
pause_input = st.sidebar.text_area("Pauser", value="09:50-10:10, 11:45-12:15, 13:50-14:00", help="Format: start-slut, adskilt af komma.")

def parse_pauser(pause_str):
    pauser = []
    matches = re.findall(r"(\\d{1,2}[:.]\\d{2})\\s*-\\s*(\\d{1,2}[:.]\\d{2})", pause_str)
    for m in matches:
        try:
            p_s = datetime.strptime(m[0].replace(".", ":"), "%H:%M")
            p_e = datetime.strptime(m[1].replace(".", ":"), "%H:%M")
            pauser.append((p_s, p_e))
        except: continue
    return sorted(pauser)

def is_overlapping(s1, e1, s2, e2):
    return s1 < e2 and e1 > s2

def solve_scheduling_smart_tables(df, start_str, pauses):
    try:
        start_str = start_str.replace(".", ":")
        global_start = datetime.strptime(start_str, "%H:%M")
    except: return None

    # 1. Beregn l√¶rer-belastning (vigtigt for at udpege 'V√¶rten')
    t_counts = pd.concat([df['L√¶rer1'], df['L√¶rer2']]).value_counts().to_dict()
    df['priority'] = df.apply(lambda r: t_counts.get(r['L√¶rer1'], 0) + t_counts.get(r['L√¶rer2'], 0), axis=1)
    
    # Planl√¶g tider f√∏rst (kompakt r√¶kkef√∏lge)
    df_sorted = df.sort_values(by='priority', ascending=False)
    teacher_busy = {}
    planned_sessions = []

    for _, row in df_sorted.iterrows():
        l1, l2 = str(row['L√¶rer1']).strip(), str(row['L√¶rer2']).strip()
        curr = global_start
        found = False
        while not found:
            endt = curr + timedelta(minutes=varighed)
            if any(is_overlapping(curr, endt, ps, pe) for ps, pe in pauses):
                curr = next(pe for ps, pe in pauses if is_overlapping(curr, endt, ps, pe))
                continue
            conflict = False
            for l in set([l1, l2]):
                if any(is_overlapping(curr, endt, bs, be) for bs, be in teacher_busy.get(l, [])):
                    curr = next(be for bs, be in teacher_busy.get(l, []) if is_overlapping(curr, endt, bs, be))
                    conflict = True; break
            if not conflict: found = True
        
        for l in set([l1, l2]):
            if l not in teacher_busy: teacher_busy[l] = []
            teacher_busy[l].append((curr, endt))
            teacher_busy[l].sort()
        
        res = row.to_dict()
        res.update({'start_dt': curr, 'end_dt': endt})
        planned_sessions.append(res)

    # Sorter kronologisk til bord-tildeling
    sessions_df = pd.DataFrame(planned_sessions).sort_values(by='start_dt')

    # 2. Dynamisk bord-tildeling med pr√¶ference for kontinuitet
    table_free_at = {}        # {bord_nr: datetime}
    teacher_last_table = {}   # {l√¶rer: bord_nr}
    final_output = []

    for _, sess in sessions_df.iterrows():
        l1, l2 = str(sess['L√¶rer1']).strip(), str(sess['L√¶rer2']).strip()
        s_dt, e_dt = sess['start_dt'], sess['end_dt']
        
        # Udpeg V√¶rten (den mest travle l√¶rer)
        host = l1 if t_counts.get(l1, 0) >= t_counts.get(l2, 0) else l2
        guest = l2 if host == l1 else l1
        
        assigned_table = None
        
        # Strategi A: Kan v√¶rten blive ved sit forrige bord?
        if host in teacher_last_table:
            prev_tab = teacher_last_table[host]
            if table_free_at.get(prev_tab, global_start) <= s_dt:
                assigned_table = prev_tab

        # Strategi B: Hvis ikke, kan g√¶sten blive ved sit forrige bord?
        if not assigned_table and guest in teacher_last_table:
            prev_tab = teacher_last_table[guest]
            if table_free_at.get(prev_tab, global_start) <= s_dt:
                assigned_table = prev_tab

        # Strategi C: Find det f√∏rste ledige bord (genbrug lave numre f√∏rst)
        if not assigned_table:
            t_nr = 1
            while True:
                if table_free_at.get(t_nr, global_start) <= s_dt:
                    assigned_table = t_nr
                    break
                t_nr += 1
        
        # Opdater registre
        table_free_at[assigned_table] = e_dt
        teacher_last_table[host] = assigned_table
        teacher_last_table[guest] = assigned_table # G√¶sten husker ogs√• dette bord til n√¶ste gang
        
        sess['Bord'] = f"Bord {assigned_table}"
        sess['Starttid'] = s_dt.strftime("%H:%M")
        sess['Sluttid'] = e_dt.strftime("%H:%M")
        final_output.append(sess)

    res_df = pd.DataFrame(final_output)
    return res_df.drop(columns=['priority', 'start_dt', 'end_dt']).sort_values(by=['Starttid', 'Bord'])

# --- UI ---
st.markdown("---")
st.write("**Overskrifter:** K.id., Fornavn, Efternavn, Fag1, L√¶rer1, Fag2, L√¶rer2")
uploaded_file = st.file_uploader("", type=["xlsx"])

if uploaded_file:
    try:
        input_df = pd.read_excel(uploaded_file)
        pauser = parse_pauser(pause_input)
        result = solve_scheduling_smart_tables(input_df, start_tid_str, pauser)
        
        if result is not None:
            st.success(f"‚úÖ Plan f√¶rdig! Sidste slut: {result['Sluttid'].max()}")
            
            def get_excel(data, mode):
                output = io.BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    if mode == 'laerer':
                        data.to_excel(writer, sheet_name='Samlet Plan', index=False)
                        for l in sorted(list(set(data['L√¶rer1'].astype(str)) | set(data['L√¶rer2'].astype(str)))):
                            data[(data['L√¶rer1']==l)|(data['L√¶rer2']==l)].to_excel(writer, sheet_name=f"L√¶rer {l[:25]}", index=False)
                    else:
                        data.sort_values(['Fornavn', 'Efternavn']).to_excel(writer, sheet_name='Navne', index=False)
                        d_temp = data.copy()
                        d_temp['Kl'] = d_temp['K.id.'].astype(str).str[:2]
                        for k in sorted(d_temp['Kl'].unique()):
                            d_temp[d_temp['Kl']==k].drop(columns=['Kl']).to_excel(writer, sheet_name=f"Klasse {k}", index=False)
                return output.getvalue()

            st.markdown("### Download resultater")
            c1, c2 = st.columns(2)
            c1.download_button("üìÇ Hent L√¶rer-planer", get_excel(result, 'laerer'), "laerer_planer.xlsx")
            c2.download_button("üéì Hent Elev-planer", get_excel(result, 'elev'), "elev_planer.xlsx")
    except Exception as e:
        st.error(f"Fejl: {e}")
`
        },
      });
    </script>
  </body>
</html>
